// AuthContext.js - S·ª≠a l·ªói Google Sign-In
import AsyncStorage from '@react-native-async-storage/async-storage';
import auth from '@react-native-firebase/auth';
import firestore from '@react-native-firebase/firestore';
import { GoogleSignin, statusCodes } from '@react-native-google-signin/google-signin';
import React, { createContext, useContext, useEffect, useState } from 'react';
import { Platform } from 'react-native';

const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [registering, setRegistering] = useState(false);
  const [authError, setAuthError] = useState(null);
  const [checkingPermission, setCheckingPermission] = useState(false);
  const [initialized, setInitialized] = useState(false);
  const [loadingTimeout, setLoadingTimeout] = useState(null);
  const [loginInProgress, setLoginInProgress] = useState(false);
  const [showLoading, setShowLoading] = useState(true);

  // Debounced loading state to prevent rapid changes
  const setLoadingWithDebounce = (value) => {
    if (loadingTimeout) {
      clearTimeout(loadingTimeout);
    }
    
    if (value === false) {
      // Delay turning off loading to prevent flicker
      const timeout = setTimeout(() => {
        setLoading(false);
        setLoginInProgress(false);
        setShowLoading(false);
      }, 200); // Gi·∫£m delay xu·ªëng 200ms
      setLoadingTimeout(timeout);
    } else {
      setLoading(value);
      setShowLoading(true);
      if (value === true) {
        setLoginInProgress(true);
      }
    }
  };

  useEffect(() => {
    const unsubscribe = auth().onAuthStateChanged(async (u) => {
      try {
        const justRegistered = await AsyncStorage.getItem('justRegistered');
        if (justRegistered === 'true') {
          console.log('üîÑ User v·ª´a ƒëƒÉng k√Ω, gi·ªØ ·ªü m√†n h√¨nh Auth');
          setUser(null);
          setAuthError(null);
          setLoadingWithDebounce(false);
          setInitialized(true);
          setShowLoading(false);
          return;
        }

        if (u) {
          setCheckingPermission(true);
          let retry = 0;
          let success = false;
          
          while (retry < 2 && !success) {
            try {
              const userDoc = await firestore().collection('users').doc(u.uid).get();
              if (!userDoc.exists) {
                // Kh√¥ng throw error ngay, ch·ªâ log ƒë·ªÉ debug
                console.log('‚ö†Ô∏è User kh√¥ng t·ªìn t·∫°i trong Firestore:', u.uid);
                throw new Error('not-found');
              }
              
              const userData = userDoc.data();
              console.log('‚úÖ User t·ªìn t·∫°i trong Firestore v·ªõi role:', userData.role);
              
              success = true;
              setUser({
                uid: u.uid,
                email: u.email,
                ...userData
              });
              setAuthError(null);
            } catch (err) {
              if (err.code === 'firestore/permission-denied') {
                retry++;
                if (retry >= 2) {
                  console.log('‚ùå Permission denied sau 2 l·∫ßn th·ª≠');
                  setAuthError('B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p h·ªá th·ªëng. Vui l√≤ng li√™n h·ªá nh√† tr∆∞·ªùng ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.');
                  await auth().signOut();
                  setUser(null);
                }
              } else if (err.message === 'not-found') {
                // User kh√¥ng t·ªìn t·∫°i trong Firestore - ƒë√¢y l√† tr∆∞·ªùng h·ª£p b√¨nh th∆∞·ªùng cho guests
                console.log('‚ÑπÔ∏è User kh√¥ng c√≥ trong collection users (c√≥ th·ªÉ l√† guest)');
                setUser({
                  uid: u.uid,
                  email: u.email
                });
                setAuthError(null);
                success = true;
              } else {
                console.log('‚ùå L·ªói kh√°c:', err);
                setAuthError('L·ªói k·∫øt n·ªëi ho·∫∑c h·ªá th·ªëng. Vui l√≤ng th·ª≠ l·∫°i sau.');
                await auth().signOut();
                setUser(null);
                break;
              }
            }
          }
          setCheckingPermission(false);
        } else {
          setUser(null);
          setAuthError(null);
        }
      } catch (error) {
        console.error('‚ùå L·ªói trong onAuthStateChanged:', error);
        setUser(null);
        setAuthError('L·ªói kh·ªüi t·∫°o ·ª©ng d·ª•ng. Vui l√≤ng th·ª≠ l·∫°i.');
      } finally {
        setLoadingWithDebounce(false);
        setInitialized(true);
        setShowLoading(false);
      }
    });
    
    return () => {
      unsubscribe();
      if (loadingTimeout) {
        clearTimeout(loadingTimeout);
      }
    };
  }, []);

  // ƒêƒÉng nh·∫≠p email/password
  const signIn = (email, pass) =>
    auth().signInWithEmailAndPassword(email, pass);

  // ƒêƒÉng k√Ω email/password
  const signUp = async (userData) => {
    setRegistering(true);
    try {
      console.log('üìù B·∫Øt ƒë·∫ßu ƒëƒÉng k√Ω user v·ªõi data:', { userData });
      
      const { email, password, phoneNumber, fullName } = userData;
      
      const userCredential = await auth().createUserWithEmailAndPassword(email, password);
      const { uid } = userCredential.user;
      
      console.log('‚úÖ T·∫°o Firebase Auth user th√†nh c√¥ng, UID:', uid);
      
      // Chu·∫©n b·ªã data cho Firestore (ch·ªâ c√°c tr∆∞·ªùng c·∫ßn thi·∫øt)
      const guestData = {
        uid,
        email: email.toLowerCase().trim(),
        fullName: fullName?.trim() || null,
        phone: phoneNumber?.trim() || null,
        createdAt: firestore.FieldValue.serverTimestamp(),
      };
      
      // T·∫°o document trong Firestore v·ªõi transaction
      await firestore().runTransaction(async (transaction) => {
        const guestRef = firestore().collection('guests').doc(uid);
        transaction.set(guestRef, guestData);
      });
      
      console.log('‚úÖ T·∫°o guest document th√†nh c√¥ng');
      
      await AsyncStorage.setItem('justRegistered', 'true');
      console.log('üèÅ ƒê√£ set flag justRegistered = true');
      
      await auth().signOut();
      console.log('üö™ ƒê√£ ƒëƒÉng xu·∫•t user sau khi ƒëƒÉng k√Ω');
      
      return {
        success: true,
        user: userCredential.user,
        userData: guestData
      };
      
    } catch (error) {
      console.log('‚ùå L·ªói trong qu√° tr√¨nh ƒëƒÉng k√Ω:', error);
      
      if (error.code !== 'auth/email-already-in-use') {
        try {
          const currentUser = auth().currentUser;
          if (currentUser) {
            await currentUser.delete();
            console.log('üßπ ƒê√£ x√≥a user auth do l·ªói t·∫°o document');
          }
        } catch (deleteError) {
          console.log('‚ö†Ô∏è Kh√¥ng th·ªÉ x√≥a user auth:', deleteError);
        }
      }
      
      try {
        await AsyncStorage.removeItem('justRegistered');
      } catch (clearError) {
        console.log('‚ö†Ô∏è Kh√¥ng th·ªÉ clear flag justRegistered:', clearError);
      }
      
      throw error;
    } finally {
      setRegistering(false);
    }
  };

  // ƒêƒÉng nh·∫≠p Google - S·ª¨A L·ªñI GOOGLE PLAY SERVICES
  const signInWithGoogle = async () => {
    try {
      console.log('üîç B·∫Øt ƒë·∫ßu Google Sign-In...');
      
      // Cleanup session c≈©
      try {
        await GoogleSignin.signOut();
        console.log('üßπ ƒê√£ clear Google session c≈©');
      } catch (signOutError) {
        console.log('‚ö†Ô∏è Kh√¥ng th·ªÉ clear session c≈©:', signOutError.message);
      }
      
      // Ki·ªÉm tra Google Play Services CH·ªà KHI TH·ª∞C S·ª∞ C·∫¶N
      if (Platform.OS === 'android') {
        try {
          console.log('üîß Ki·ªÉm tra Google Play Services...');
          await GoogleSignin.hasPlayServices({ 
            showPlayServicesUpdateDialog: true 
          });
          console.log('‚úÖ Google Play Services OK');
        } catch (playServicesError) {
          console.log('‚ùå Google Play Services Error:', playServicesError);
          
          // X·ª≠ l√Ω l·ªói c·ª• th·ªÉ cho Google Play Services
          if (playServicesError.code === statusCodes.PLAY_SERVICES_NOT_AVAILABLE) {
            throw new Error('Google Play Services kh√¥ng kh·∫£ d·ª•ng. Vui l√≤ng c√†i ƒë·∫∑t ho·∫∑c c·∫≠p nh·∫≠t Google Play Services t·ª´ CH Play Store.');
          } else if (playServicesError.code === statusCodes.PLAY_SERVICES_OUTDATED) {
            throw new Error('Google Play Services ƒë√£ l·ªói th·ªùi. Vui l√≤ng c·∫≠p nh·∫≠t t·ª´ CH Play Store.');
          } else {
            throw new Error('L·ªói Google Play Services. Vui l√≤ng th·ª≠ l·∫°i sau.');
          }
        }
      }
      
      // Th·ª±c hi·ªán ƒëƒÉng nh·∫≠p Google
      console.log('üîë Th·ª±c hi·ªán ƒëƒÉng nh·∫≠p Google...');
      const userInfo = await GoogleSignin.signIn();
      console.log('‚úÖ Google Sign-In th√†nh c√¥ng!');

      if (!userInfo.idToken) {
        throw new Error('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c idToken t·ª´ Google');
      }
      
      // T·∫°o credential v√† ƒëƒÉng nh·∫≠p Firebase
      const googleCredential = auth.GoogleAuthProvider.credential(userInfo.idToken);
      const userCredential = await auth().signInWithCredential(googleCredential);
      
      // Ki·ªÉm tra v√† t·∫°o guest document n·∫øu ch∆∞a c√≥
      const guestDoc = await firestore().collection('guests').doc(userCredential.user.uid).get();
      
      if (!guestDoc.exists) {
        const googleGuestData = {
          uid: userCredential.user.uid,
          email: userCredential.user.email,
          fullName: userCredential.user.displayName || null,
          phone: userCredential.user.phoneNumber || null,
          createdAt: firestore.FieldValue.serverTimestamp(),
        };
        
        await firestore().collection('guests').doc(userCredential.user.uid).set(googleGuestData);
        console.log('‚úÖ T·∫°o guest document cho Google user');
      }
      
      console.log('üéâ Google Sign-In ho√†n t·∫•t, UID:', userCredential.user.uid);
      return userCredential;
      
    } catch (error) {
      console.log('‚ùå Chi ti·∫øt l·ªói Google Sign-In:', error);
      
      // Enhanced error handling
      const getGoogleErrorMessage = (error) => {
        switch (error.code) {
          case statusCodes.SIGN_IN_CANCELLED:
            return 'B·∫°n ƒë√£ h·ªßy ƒëƒÉng nh·∫≠p';
          case statusCodes.IN_PROGRESS:
            return 'ƒêang trong qu√° tr√¨nh ƒëƒÉng nh·∫≠p, vui l√≤ng ƒë·ª£i';
          case statusCodes.PLAY_SERVICES_NOT_AVAILABLE:
            return 'Google Play Services kh√¥ng kh·∫£ d·ª•ng. Vui l√≤ng c√†i ƒë·∫∑t t·ª´ CH Play Store';
          case statusCodes.SIGN_IN_REQUIRED:
            return 'C·∫ßn ƒëƒÉng nh·∫≠p l·∫°i. Vui l√≤ng th·ª≠ l·∫°i';
          default:
            if (error.message?.includes('Network error')) {
              return 'L·ªói k·∫øt n·ªëi m·∫°ng. Vui l√≤ng ki·ªÉm tra internet v√† th·ª≠ l·∫°i';
            } else if (error.message?.includes('ApiException')) {
              return 'L·ªói Google API. Vui l√≤ng th·ª≠ l·∫°i sau';
            } else if (error.message?.includes('Google Play Services')) {
              return error.message; // S·ª≠ d·ª•ng message ƒë√£ ƒë∆∞·ª£c format ·ªü tr√™n
            } else {
              return `ƒêƒÉng nh·∫≠p Google th·∫•t b·∫°i: ${error.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh'}`;
            }
        }
      };
      
      const friendlyMessage = getGoogleErrorMessage(error);
      throw new Error(friendlyMessage);
    }
  };

  // ƒêƒÉng xu·∫•t
  const signOut = async () => {
    try {
      console.log('üö™ B·∫Øt ƒë·∫ßu ƒëƒÉng xu·∫•t...');
      
      try {
        await AsyncStorage.removeItem('justRegistered');
        console.log('üßπ ƒê√£ clear flag justRegistered');
      } catch (clearError) {
        console.log('‚ö†Ô∏è Kh√¥ng th·ªÉ clear flag justRegistered:', clearError);
      }
      
      // Ki·ªÉm tra v√† ƒëƒÉng xu·∫•t Google n·∫øu c·∫ßn
      const currentUser = auth().currentUser;
      if (currentUser?.providerData?.some(provider => provider.providerId === 'google.com')) {
        try {
          await GoogleSignin.revokeAccess();
          await GoogleSignin.signOut();
          console.log('‚úÖ Google ƒëƒÉng xu·∫•t th√†nh c√¥ng');
        } catch (googleError) {
          console.log('‚ö†Ô∏è L·ªói ƒëƒÉng xu·∫•t Google (kh√¥ng ·∫£nh h∆∞·ªüng):', googleError.message);
        }
      }
      
      await auth().signOut();
      console.log('‚úÖ ƒêƒÉng xu·∫•t ho√†n t·∫•t!');
    } catch (error) {
      console.log('‚ùå L·ªói ƒëƒÉng xu·∫•t:', error);
      try {
        await auth().signOut();
      } catch (firebaseError) {
        console.log('‚ùå L·ªói ƒëƒÉng xu·∫•t Firebase:', firebaseError);
      }
    }
  };

  // Reset password
  const resetPassword = email => auth().sendPasswordResetEmail(email);

  // Helper function ƒë·ªÉ clear registration flag
  const clearRegistrationFlag = async () => {
    try {
      await AsyncStorage.removeItem('justRegistered');
      console.log('üßπ ƒê√£ clear registration flag');
    } catch (error) {
      console.log('‚ö†Ô∏è L·ªói clear registration flag:', error);
    }
  };

  return (
    <AuthContext.Provider
      value={{ 
        user, 
        loading, 
        registering, 
        initialized,
        loginInProgress,
        showLoading,
        setLoading: setLoadingWithDebounce,
        signIn, 
        signUp, 
        signInWithGoogle, 
        signOut, 
        resetPassword,
        clearRegistrationFlag,
        authError,
        checkingPermission
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};